
<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="description" content="The JDBC Multitable Consumer origin reads database data from multiple tables through a JDBC connection. The origin returns data as a map with column names and field values. By default, the origin ..." /><meta name="copyright" content="(C) Copyright 2005" /><meta name="DC.rights.owner" content="(C) Copyright 2005" /><meta name="DC.Type" content="concept" /><meta name="DC.Title" content="JDBC Multitable Consumer" /><meta name="DC.Relation" scheme="URI" content="../Origins/Origins_title.html" /><meta name="DC.Format" content="XHTML" /><meta name="DC.Identifier" content="concept_zp3_wnw_4y" /><link rel="stylesheet" type="text/css" href="../oxygen-webhelp/resources/css/commonltr.css"><!----></link><title>JDBC Multitable Consumer</title><!--  Generated with Oxygen version 18.1, build number 2016112217.  --><link rel="stylesheet" type="text/css" href="../oxygen-webhelp/resources/css/webhelp_topic.css"><!----></link><link rel="stylesheet" type="text/css" href="../oxygen-webhelp/resources/skins/skin.css" /><link rel="stylesheet" type="text/css" href="../skin.css" /><script type="text/javascript"><!--
            
            var prefix = "../index.html";
            
            --></script><script type="text/javascript" src="../oxygen-webhelp/resources/js/jquery-1.11.3.min.js"><!----></script><script type="text/javascript" src="../oxygen-webhelp/resources/js/jquery.cookie.js"><!----></script><script type="text/javascript" src="../oxygen-webhelp/resources/js/jquery-ui.custom.min.js"><!----></script><script type="text/javascript" src="../oxygen-webhelp/resources/js/jquery.highlight-3.js"><!----></script><script type="text/javascript" charset="utf-8" src="../oxygen-webhelp/resources/js/webhelp_topic.js"><!----></script>
<!--
    Copyright 2017 StreamSets Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-->
</head>
<body onload="highlightSearchTerm()" class="frmBody">
<table class="nav"><tbody><tr><td colspan="2"><div id="printlink"><a href="javascript:window.print();" title="Print this page"></a></div><div id="permalink"><a href="#" title="Link to this page"></a></div></td></tr><tr><td style="width:75%;"><span class="topic_breadcrumb_links"><span class="topic_breadcrumb_link"><a class="navheader_parent_path" href="../Origins/Origins_title.html" title="Origins">Origins</a></span></span></td><td><span id="topic_navigation_links" class="navheader">
<span class="navparent"><a class="link" href="../Origins/Origins_title.html" title="Origins"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">Origins</span></a></span>  </span></td></tr></tbody></table>
<div class="nested0" id="concept_zp3_wnw_4y">
 <h1 class="title topictitle1">JDBC Multitable Consumer</h1>

 <div class="body conbody">
  <p class="p">The JDBC
            Multitable Consumer origin reads database data from multiple tables through a JDBC
            connection. The origin returns data as a map with column names and field values. </p>

        <p class="p">By default, the origin processes tables incrementally, using primary key columns or
            user-defined offset columns to track its progress. You can configure the origin to
            perform non-incremental processing to enable it to also process tables that do not have
            a key or offset column.</p>

        <p class="p">The origin can use multiple threads to enable parallel processing of tables and
            partitions. Use the JDBC Multitable Consumer origin to read multiple tables in the same
            database. For example, you might use the origin to perform database replication. </p>

        <p class="p">When you configure the JDBC Multitable Consumer origin, you define groups of database
            tables to read. The origin generates SQL queries based on the table configurations that
            you define. </p>

        <div class="note note"><span class="notetitle">Note:</span> To configure your own SQL query to read database data from a single table or from a
            join of tables, use the <a class="xref" href="JDBCConsumer.html#concept_qhf_hjr_bs" title="JDBC Query Consumer uses an offset column and initial offset value to determine where to start reading data within a table. Include both the offset column and the offset value in the WHERE clause of the SQL query. JDBC Query Consumer supports recovery after a deliberate or unexpected stop when it performs incremental queries. Recovery is not supported for full queries.When you define the SQL query for incremental mode, JDBC Query Consumer requires a WHERE and ORDER BY clause in the query. You can define any type of SQL query for full mode.">JDBC Query Consumer</a>
            origin.</div>

        <p class="p">When you configure the origin, you specify connection information and custom JDBC
            configuration properties to determine how the origin connects to the database. You also
            configure the number of threads to use and the maximum number of queries to run per
            second.</p>

        <p class="p">When you define the table configuration for the groups of tables that you want to
            process, you can optionally override the default key column and specify the initial
            offset to use. You can enable non-incremental processing for tables without key or
            offset columns. You can configure the origin to perform multithreaded partition
            processing, multithreaded table processing, or use the default - a mix of both. When
            configuring partitions, you can configure the offset size, number of active partitions,
            and offset conditions. </p>

        <p class="p">You define the strategy that the origin uses to create each batch of data and the number
            of batches to create from each result set. You can configure advanced properties, such
            as the initial order to read from tables, connection related properties, and transaction
            isolation. <span class="ph">And you can specify what the origin does when
                        encountering an unsupported data type: convert the data to string or stop
                        the pipeline.</span></p>

        <p class="p">When the pipeline stops, JDBC Multitable Consumer notes where it stops reading. When the
            pipeline starts again, JDBC Multitable Consumer continues processing from where it
            stopped by default. You can reset the origin to process all available data, using any
            initial offsets that you defined.</p>

        <p class="p"><span class="ph">To use a JDBC version older than
                        4.0, you can specify the driver class name and define a health check
                        query.</span></p>

        <p class="p">The origin can generate events for an event stream. For
                  more information about dataflow triggers and the event framework, see <a class="xref" href="../Event_Handling/EventFramework-Title.html#concept_cph_5h4_lx">Dataflow Triggers Overview</a>. </p>

 </div>

<div class="related-links"></div>
<div class="topic concept nested1" id="concept_zsr_31x_4y">
 <h2 class="title topictitle2">Installing the JDBC Driver</h2>

 <div class="body conbody">
        <p class="p">Before you use the JDBC Multitable Consumer, <span class="ph">install the JDBC driver for the database. You cannot access
                        the database until you install the required driver. </span></p>

        <p class="p"><span class="ph">For information about installing additional drivers, see
                              <a class="xref" href="../Configuration/ExternalLibs.html#concept_pdv_qlw_ft" title="After you've set up the external directory, use the Package Manager within Data Collector to install external libraries.To manually install external libraries, use the required procedure for your installation type.">Install External Libraries</a>.</span></p>

 </div>

<div class="topic concept nested2" id="concept_bnp_zhb_ty">
 <h3 class="title topictitle3">Working with a MySQL JDBC Driver</h3>

 <div class="body conbody">
  <div class="p">Note the following issues that can occur when using a MySQL JDBC driver with the JDBC
            Multitable Consumer origin:<dl class="dl">
                
                    <dt class="dt dlterm">The driver returns time values to the second.</dt>

                    <dd class="dd">
                        <p class="p">Due to a MySQL JDBC driver issue, the driver cannot return time values to
                            the millisecond. Instead, the driver returns the values to the second.
                            For example, if a column has a value of 20:12:50.581, the driver reads
                            the value as 20:12:50.000.</p>

                    </dd>

                
                
                    <dt class="dt dlterm">The origin might not read new rows created in MySQL while the pipeline is
                        running.</dt>

                    <dd class="dd">When using the default transaction isolation level, the origin might not
                        read new rows that are created in MySQL as the pipeline is running. To
                        resolve this issue, configure the origin to use the read committed
                        transaction isolation level in the Advanced tab.</dd>

                
            </dl>
</div>

 </div>

</div>
</div>
<div class="topic concept nested1" id="concept_rx3_3hx_4y">
 <h2 class="title topictitle2">Table Configuration</h2>

 <div class="body conbody">
        <p class="p">When you configure JDBC
            Multitable Consumer, you define a table configuration for each group of tables that you
            want to read. A table configuration defines a group of tables from the same schema, that
            have the same table name pattern, and that have proper primary keys or have the same
            user-defined offset columns.</p>

        <p class="p">You can define one or more table configurations. </p>

        <p class="p">For example, you can define one table configuration to replicate a database that has a
            proper primary key for each table. You simply define the schema name and use the default
            table name pattern <samp class="ph codeph">%</samp> which matches all tables in the schema.</p>

        <div class="p">Let's look at an example where you need to define more than one table configuration.
            Let's say that you want to copy tables in a relational database to an HBase cluster. The
            SALES schema contains ten tables, but you want to copy only the following four
                tables:<ul class="ul" id="concept_rx3_3hx_4y__ul_ivp_hcy_4y">
                <li class="li">store_a</li>

                <li class="li">store_b</li>

                <li class="li">store_c</li>

                <li class="li">customers</li>

            </ul>
</div>

        <p class="p">The three store tables use orderID as the primary key. You want to override the primary
            key for the customers table, and so need to define customerID as the offset column for
            that table. You want to read all available data in the tables, so do not need to define
            an initial offset value.</p>

        <p class="p">You define the following two table configurations for the origin so that the origin can
            read all four tables:</p>

        <p class="p"><img class="image" id="concept_rx3_3hx_4y__image_vck_yjl_pbb" src="../Graphics/MultiTableJDBC_TableConfig.png" height="544" width="688" /></p>

        <p class="p">Let's take a closer look at the table name pattern and offset properties that you define
            in a table configuration.</p>

 </div>

<div class="topic concept nested2" id="concept_ank_41x_4y">
 <h3 class="title topictitle3">Table Name Pattern</h3>

 
 <div class="body conbody"><p class="shortdesc">You define the group of tables that the JDBC Multitable Consumer origin reads by
        defining a table name pattern for the table configuration. The origin reads all tables whose
        names match the pattern. </p>

  <p class="p">The table name pattern uses
            the SQL LIKE syntax. For example, the LIKE syntax uses the percentage wildcard (%) to
            represent any string of zero or more characters. The table name pattern
                <samp class="ph codeph">st%</samp> matches tables whose names start with "st". The default table
            name pattern <samp class="ph codeph">%</samp> matches all tables in the schema.</p>

        <p class="p">For more information about valid patterns for the SQL LIKE syntax, see <a class="xref" href="https://msdn.microsoft.com/en-us/library/ms179859.aspx" target="_blank">https://msdn.microsoft.com/en-us/library/ms179859.aspx</a>.</p>

        <p class="p">You can optionally define a table exclusion pattern to exclude some tables from being
            read. The table exclusion pattern uses a Java-based regular expression, or regex. For
            more information about using regular expressions with <span class="ph">Data
                  Collector</span>,
            see <a class="xref" href="../Apx-RegEx/RegEx-Title.html#concept_vd4_nsc_gs" title="A regular expression, also known as regex, describes a pattern for a string.">Regular Expressions Overview</a>.</p>

        <div class="p">For example, let's say that you want to read all tables in the schema except for tables
            that start with "dept". You enter the following table name and table exclusion patterns:
                <ul class="ul" id="concept_ank_41x_4y__ul_z3z_h2r_qy">
                <li class="li">Table Name Pattern - %</li>

                <li class="li">Table Exclusion Pattern - dept*</li>

            </ul>
</div>

        <p class="p">If you do not need to exclude any tables, simply leave the table exclusion pattern
            empty.</p>

 </div>

</div>
<div class="topic concept nested2" id="concept_yfx_mhx_4y">
 <h3 class="title topictitle3">Offset Column and Value</h3>

 
 <div class="body conbody"><p class="shortdesc">The JDBC Multitable Consumer origin uses an offset column and initial offset value to
        determine where to start reading data within tables and partitions.</p>

        <p class="p">By default, the origin uses the
            primary key of the tables as the offset column and uses no initial offset value. When
            you use multithreaded table processing and the table has a composite primary key, the
            origin uses each primary key as an offset column. You cannot use composite keys with
            multithreaded partition processing. </p>

        <div class="p">By default, the origin reads all available data from each table when you start the
            pipeline. The origin generates SQL queries using the following syntax when you start the
            pipeline:<pre class="pre codeblock">SELECT * FROM &lt;table&gt; ORDER BY &lt;offset column_1&gt;, &lt;offset column_2&gt;, ...</pre>
</div>

        <p class="p">Where <samp class="ph codeph">&lt;offset column_<em class="ph i">n</em>&gt;</samp> represents each primary key of the
            table, such as when the table has a composite primary key. When you restart the pipeline
            or when the origin switches back to a previously read table, the origin adds a WHERE
            clause to the SQL query to continue reading from the last saved offset.</p>

        <p class="p">To use this default behavior, you do not need to configure any of the offset
            properties.</p>

        <div class="p">You can make the following changes to how the origin handles offset columns and initial
            offset values:<dl class="dl">
                
                    <dt class="dt dlterm">Override the primary key as the offset column</dt>

                    <dd class="dd">You can override the primary key and define another offset column or
                        columns. Or if the table doesnâ€™t have a primary key, you can define the
                        offset column or columns to use. </dd>

                    <dd class="dd">
                        <div class="note important"><span class="importanttitle">Important:</span> As a best practice, a user-defined offset column
                            should be an incremental and unique column. If the column is not unique
                            - that is, multiple rows can have the same value for this column - there
                            is a potential for data loss upon pipeline restart. For details, see
                                <a class="xref" href="MultiTableJDBCConsumer.html#concept_d52_4l1_q1b">Multiple Offset Value Handling</a>. </div>

                    </dd>

                    <dd class="dd">Having an index on this column is strongly encouraged since the underlying
                        query uses an ORDER BY and inequality operators on this column.</dd>

                
                
                    <dt class="dt dlterm">Define an initial offset value</dt>

                    <dd class="dd">The initial offset value is a value within the offset column where you want
                        JDBC Multitable Consumer to start reading. When you define an initial offset
                        value, you must first enter the offset column name and then the value. If
                        you are using the default primary key as the offset column, enter the name
                        of the primary key.</dd>

                    <dd class="dd">If you define an initial offset value for a single offset column, the origin
                        generates SQL queries using the following
                        syntax:<pre class="pre codeblock">SELECT * FROM &lt;table&gt; ORDER BY &lt;offset column&gt; WHERE &lt;offset column&gt; &gt; ${offset}</pre>
</dd>

                    <dd class="dd">If you defined multiple offset columns, you must define an initial offset
                        value for each column, in the same order that the columns are defined. The
                        origin uses the initial offset values of all columns to determine where to
                        start reading data. For example, you override the primary key with the
                        following offset columns: p1, p2, p3 and define an initial offset value for
                        each column. The origin generates SQL queries using the following syntax:<pre class="pre codeblock">SELECT * FROM &lt;table&gt; ORDER BY p1, p2, p3 WHERE (p1 &gt; ${offset1}) OR (p1 = ${offset1} AND p2 &gt; ${offset2}) OR (p1 = ${offset1} AND p2 = ${offset2} AND p3 &gt; ${offset3})</pre>
<div class="p">
                            <div class="note note"><span class="notetitle">Note:</span> <span class="ph">Data
                  Collector</span> stores offsets for Datetime columns as Long values. For offset
                                columns with a Datetime data type, enter the initial value as a Long
                                value. You can use the time functions to transform a Datetime value
                                to a Long value. For example, the following expression converts a
                                date entered as a String to a Date object, and then to a Long value:<div class="p">
                                    <pre class="pre codeblock">${time:dateTimeToMilliseconds(time:extractDateFromString('2017-05-01 20:15:30.915','yyyy-MM-dd HH:mm:ss.SSS'))} </pre>

                                </div>
</div>

                        </div>
</dd>

                
                
                    <dt class="dt dlterm">Define additional offset column conditions</dt>

                    <dd class="dd">You can use the expression language to define additional conditions that the
                        origin uses to determine where to start reading data. The origin adds the
                        defined condition to the WHERE clause of the SQL query.</dd>

                    <dd class="dd">You can use the offset:column function in the condition to access an offset
                        column by position. For example, if you have a table with offset columns p1
                        and p2, then offset:column(0) returns the value of p1 while offset:column(1)
                        returns the value of p2.</dd>

                    <dd class="dd">Let's say that you defined a transaction_time column as the offset column.
                        While the origin reads the table, multiple active transactions are being
                        written to the table with the current timestamp for the transaction_time
                        column. When the origin finishes reading the first record with the current
                        timestamp, the origin continues reading with the next offset and skips some
                        rows with the current timestamp. You can enter the following offset column
                        condition to ensure that the origin reads from all offset columns with a
                        timestamp less than the current
                        time:<pre class="pre codeblock">${offset:column(0)} &lt; ${time:now()}</pre>
</dd>

                    <dd class="dd">If your database requires the datetime in a specific format, you can use the
                            <span class="ph">time:extractStringFromDate</span> function to specify the format. For
                        example:
                        <pre class="pre">${offset:column(0)} &lt; '${time:extractStringFromDate(time:now(), "yyyy-MM-dd HH:mm:ss")}'</pre>
</dd>

                
            </dl>
</div>

    </div>

</div>
</div>
<div class="topic concept nested1" id="concept_m43_zzm_dbb">
 <h2 class="title topictitle2">Reading from Views</h2>

 
 <div class="body conbody"><p class="shortdesc">The JDBC Multitable Consumer origin can read from views in addition to tables. </p>

        <p class="p">The origin reads from all
            tables and views that are included in the defined table configurations. If a table
            configuration includes views that you do not want to read, simply exclude them from the
            configuration.</p>

        <p class="p">Use the origin to read from simple views that select data from a single table. </p>

        <p class="p">We do not recommend using the origin to read from complex views that combine data from
            two or more tables using joins. If the origin reads from complex views, it runs multiple
            queries in parallel which can cause a heavy workload on the database. </p>

    </div>

</div>
<div class="topic concept nested1" id="concept_nbk_xgt_p1b">
 <h2 class="title topictitle2">Multithreaded Processing Modes</h2>

 <div class="body conbody">
  <p class="p">The JDBC Multitable Consumer origin performs parallel
            processing and enables the creation of a multithreaded pipeline. The origin can use
            multiple threads to process entire tables or partitions within tables. </p>

        <p class="p">By default, the origin performs multithreaded partition processing for the tables that
            fulfill the partition processing requirements, and performs multithreaded table
            processing for all other tables. When using the default behavior, the origin notes the
            tables that allow partition processing in the <span class="ph">Data
                  Collector</span>
            log. When needed, you can configure the origin to require partition processing for all
            tables or to perform only table processing. You can also allow the single-threaded <a class="xref" href="MultiTableJDBCConsumer.html#concept_xwr_bhm_nbb">non-incremental processing</a> of tables when needed.</p>

        <div class="p">The origin provides the following multithreaded processing modes:<ul class="ul" id="concept_nbk_xgt_p1b__ul_trr_gxt_p1b">
                <li class="li"><a class="xref" href="MultiTableJDBCConsumer.html#concept_tz5_fw5_gz">Multithreaded table processing</a> - The origin can use up to one thread
                    per table. Can process tables with multiple offset columns.</li>

                <li class="li"><a class="xref" href="MultiTableJDBCConsumer.html#concept_gvy_yws_p1b">Multithreaded partition processing</a> - The origin can use up to one
                    thread per table partition. Use to process larger volumes of data than
                    multithreaded table processing.<p class="p">Multithreaded partition processing requires a
                        single primary key or user-defined offset column of a supported data type,
                        and additional details for partition creation. Tables with composite keys or
                        a key or user-defined offset column of an unsupported data type cannot be
                        partitioned.</p>
</li>

            </ul>
</div>

        <div class="p">When you configure the origin, you specify the tables to process and the multithreaded
            partition processing mode to use for each set of tables: <ul class="ul" id="concept_nbk_xgt_p1b__ul_qk1_g2j_t1b">
                <li class="li">Off - Use to perform multithreaded table processing. <p class="p">Can be used to perform
                        non-incremental loads of tables without key or offset columns, when
                        enabled.</p>
</li>

                <li class="li">On (Best Effort) - Use to perform partition processing where possible and allow
                    multithreaded table processing for tables with multiple key or offset columns.
                        <p class="p">Can be used to perform non-incremental loads of tables without key or
                        offset columns, when enabled. </p>
</li>

                <li class="li">On (Required) - Use to perform partition processing for all specified tables.
                        <p class="p">Does not allow performing other types of processing for tables that do
                        not meet the partition processing requirements.</p>
</li>

            </ul>
</div>

 </div>

</div>
<div class="topic concept nested1" id="concept_tz5_fw5_gz">
 <h2 class="title topictitle2">Multithreaded Table Processing</h2>

 <div class="body conbody">
  <div class="p">When performing multithreaded table
            processing, the JDBC Multitable Consumer origin retrieves the list of tables defined in
            the table configuration when you start the pipeline. The origin then uses multiple
            concurrent threads based on the Number of Threads property. Each thread reads data from
            a single table, and each table can have a maximum of one thread read from it at a
                time.<div class="note note"><span class="notetitle">Note:</span> The Maximum Pool Size property on the Advanced tab defines the maximum
                number of connections the origin can make to the database. It must be equal to or
                greater than the value defined for the Number of Threads property.</div>
</div>

        <p class="p">As the pipeline runs, <span class="ph">each thread connects to the origin system
                        and creates a batch of data, and passes the batch to an available pipeline
                        runner. A pipeline runner is a <dfn class="term">sourceless pipeline instance</dfn> -
                        an instance of the pipeline that includes all of the processors and
                        destinations in the pipeline and performs all pipeline processing after the
                        origin.</span></p>

        <p class="p"><span class="ph"> Each pipeline runner processes one batch at a time,
                        just like a pipeline that runs on a single thread. When the flow of data
                        slows, the pipeline runners wait idly until they are needed.</span></p>

        <p class="p"><span class="ph">Multithreaded pipelines preserve the order of
                        records within each batch, just like a single-threaded pipeline. But since
                        batches are processed by different pipeline instances, the order that
                        batches are written to destinations is not ensured.</span></p>

        <p class="p">The order of batch processing depends on many factors. For more information, see <a class="xref" href="MultiTableJDBCConsumer.html#concept_czt_ql2_r1b">Understanding the Processing Queue</a>.</p>

        <p class="p">For more information about multithreaded pipelines, see <a class="xref" href="../Multithreaded_Pipelines/MultithreadedPipelines.html#concept_zpp_2xc_py">Multithreaded Pipeline Overview</a>.</p>

        <div class="section" id="concept_tz5_fw5_gz__section_fvq_bpw_hz"><h3 class="title sectiontitle">Example</h3>
            
            <p class="p">Say you are reading from ten tables. You set the Number of Threads property to 5 and
                the Maximum Pool Size property to 6. When you start the pipeline, the origin
                retrieves the list of tables. The origin then creates five threads to read from the
                first five tables, and by default <span class="ph">Data
                  Collector</span> creates a matching number of pipeline runners. Upon receiving data, a thread
                passes a batch to each of the pipeline runners for processing.</p>

            <p class="p">At any given moment, the five pipeline runners can each
                  process a batch, so this multithreaded pipeline processes up to five batches at a
                  time. When incoming data slows, the pipeline runners sit idle, available for use
                  as soon as the data flow increases.</p>

        </div>

 </div>

</div>
<div class="topic concept nested1" id="concept_gvy_yws_p1b">
    <h2 class="title topictitle2">Multithreaded Partition Processing</h2>

    <div class="body conbody">
        <p class="p">By default, the JDBC Multitable Consumer
            origin performs multithreaded partition processing for all tables that meet the
            partition processing requirements, and performs table processing for all other tables. </p>

        <p class="p">To perform multithreaded processing of partitions within a table, you enable partition
            processing in the table configuration, then specify the partition size and the maximum
            number of partitions to use. Limiting the number of partitions also limits the number of
            threads that can be dedicated to processing data in the table. </p>

        <p class="p">When you configure a set of tables for unlimited partitions, the origin creates up to
            twice as many partitions as the pipeline thread count. For example, if you have 5
            threads, the table can have up to 10 partitions. </p>

        <p class="p">Similar to multithreaded table processing, each thread reads data from a single
            partition, and each partition can have a maximum of one thread read from it at a time. </p>

        <p class="p">When processing partitions, the processing order depends on many factors. For a full
            description, see <a class="xref" href="MultiTableJDBCConsumer.html#concept_czt_ql2_r1b">Understanding the Processing Queue</a>.</p>

    </div>

<div class="topic concept nested2" id="concept_c54_hj1_q1b">
 <h3 class="title topictitle3">Partition Processing Requirements</h3>

 <div class="body conbody">
  <p class="p">To
            perform multithreaded partition processing for a table, the table must meet the
            following requirements:</p>

        <div class="p">
            <dl class="dl">
                
                    <dt class="dt dlterm">Single key or offset column</dt>

                    <dd class="dd">The table must have a single primary key or user-defined offset column.
                        Performing multithreaded partition processing on a table with composite keys
                        generates an error and stops the pipeline.</dd>

                    <dd class="dd">If a table does not have a primary key column, you can use the Override
                        Offset Columns property to specify a valid offset column to use. Having an
                        ascending index on the offset column is strongly encouraged since the
                        underlying query uses an ORDER BY and inequality operators on this
                        column.</dd>

                
                
                    <dt class="dt dlterm">Numeric data type</dt>

                    <dd class="dd">To use partition processing, the primary key or user-defined offset column
                        must have a numeric data type that allows arithmetic partitioning. </dd>

                    <dd class="dd">The key or offset column must be one of the following data types:<ul class="ul" id="concept_c54_hj1_q1b__ul_kdf_sj1_q1b">
                            <li class="li">Integer-based: Integer, Smallint, Tinyint</li>

                            <li class="li">Long-based: Bigint, Date, Time, Timestamp</li>

                            <li class="li">Float-based: Float, Real</li>

                            <li class="li">Double-based: Double</li>

                            <li class="li">Precision-based: Decimal, Numeric</li>

                        </ul>
</dd>

                
            </dl>

        </div>

 </div>

</div>
<div class="topic concept nested2" id="concept_d52_4l1_q1b">
 <h3 class="title topictitle3">Multiple Offset Value Handling</h3>

 <div class="body conbody">
  <p class="p">When processing partitions, JDBC Multitable Consumer
            origin allows processing multiple records with the same offset value. For example, the
            origin can process multiple records with the same timestamp in a transaction_date offset
            column.</p>

        <div class="p">
            <div class="note warning"><span class="warningtitle">Warning:</span> When processing multiple records with the same offset value,
                records can be dropped if you stop the pipeline when the origin is processing a
                series of records with the same offset value.</div>

        </div>

        <p class="p">When you stop the pipeline as the origin is processing a series of records with the same
            offset value, the origin notes the offset. Then, when you restart the pipeline, it
            starts with a record with the next logical offset value, skipping any unprocessed
            records that use the same last-saved offset. </p>

        <p class="p">For example, say you specified a datetime column as a user-defined offset column, and
            five records in the table share the same datetime value. Now say you happen to stop the
            pipeline after it processes the second record. The pipeline stores the datetime value as
            the offset where it stopped. When you restart the pipeline, processing begins with the
            next datetime value, skipping the three unprocessed records with the last-saved offset
            value. </p>

 </div>

</div>
<div class="topic concept nested2" id="concept_im5_nqw_4bb">
 <h3 class="title topictitle3">Best Effort: Processing Non-Compliant Tables</h3>

 <div class="body conbody">
  <p class="p">To process tables in a table configuration that might not meet the partition processing
            requirements, you can use the On (Best Effort) option when you configure the
            Multithreaded Partition Processing mode property. </p>

        <p class="p">When you select the best effort option, the origin performs multithreaded partition
            processing for all tables that meet the partition processing requirements. The origin
            performs multithreaded table processing for tables that include multiple key or offset
            columns. And if you enable <a class="xref" href="MultiTableJDBCConsumer.html#concept_xwr_bhm_nbb">non-incremental processing</a>, the origin can also process all tables that do
            not include key or offset columns. </p>

 </div>

</div>
</div>
<div class="topic concept nested1" id="concept_xwr_bhm_nbb">
 <h2 class="title topictitle2">Non-Incremental Processing</h2>

 <div class="body conbody">
  <p class="p">You can
            configure the JDBC Multitable Consumer origin to perform non-incremental processing for
            tables with no primary keys or user-defined offset columns. By default, the origin
            performs incremental processing and does not process tables without a key or offset
            column. </p>

        <p class="p">You can enable non-incremental processing for the set of tables defined in a table
            configuration.</p>

        <div class="p">
            <div class="note note"><span class="notetitle">Note:</span> When enabling non-incremental processing for a table without a key or offset
                column, you cannot require <a class="xref" href="MultiTableJDBCConsumer.html#concept_gvy_yws_p1b">multithreaded partition processing</a> for the table configuration. That is,
                you cannot run the pipeline with the Multithreaded Partition Processing Mode
                property set to On (Required).</div>

        </div>

        <p class="p">Use On (Best Effort) or Off to perform non-incremental processing of the table. With
            either option selected, table is processed using a single thread, like <a class="xref" href="MultiTableJDBCConsumer.html#concept_tz5_fw5_gz">multithreaded
                table processing</a>. </p>

        <div class="p">When you enable non-incremental processing, the origin processes any table without a key
            or offset column as follows:<ul class="ul" id="concept_xwr_bhm_nbb__ul_tzt_2nm_nbb">
                <li class="li">The origin uses a single thread to process all available data in the table. </li>

                <li class="li">After the origin processes all available data, it notes that the table has been
                    processed as an offset. So, if you stop and restart the pipeline after the
                    origin completes all processing, the origin does not reprocess the table. <p class="p">If
                        you want to reprocess data in the table, you can reset the origin before
                        restarting the pipeline. This resets the origin for all tables that the
                        origin processes.</p>
</li>

                <li class="li">If the pipeline stops while the origin is still processing available data, when
                    the pipeline restarts, the origin reprocesses the entire table. This occurs
                    because the table has no key or offset column to allow for tracking progress.
                </li>

            </ul>
</div>

        <p class="p">For example, say you configure the origin to use five threads and process a set of tables
            that includes a table with no key or offset column. To process data in this table, you
            enable the Enable Non-Incremental Load table configuration property. You also set
            Multithreaded Partition Processing Mode to On (Best Effort) o allow the origin to use
            multithreaded partition processing when possible and allow both non-incremental
            processing and multithreaded table processing when needed.</p>

        <p class="p">When you start the pipeline, the origin allocates one thread to the table that requires
            non-incremental processing. It processes the table data using multithreaded table
            processing until all data is processed. When the thread completes processing all
            available data, the origin notes this as part of the offset and the thread becomes
            available to process data from other tables. In the meantime, the four other threads
            process data from the rest of the tables using multithreaded partition processing when
            possible. </p>

 </div>

</div>
<div class="topic concept nested1" id="concept_n5t_zgx_4y">
 <h2 class="title topictitle2">Batch Strategy</h2>

 <div class="body conbody">
        <p class="p">You can specify the batch strategy to use
            when processing data. The batch strategy behaves differently depending on whether you
            use multithreaded table processing or multithreaded partition processing. The behavior
            can also be affected by the Batches from Result Set property.</p>

 </div>

<div class="topic concept nested2" id="concept_e4d_fg3_v1b">
 <h3 class="title topictitle3">Process All Available Rows</h3>

 <div class="body conbody">
  <div class="p">The Process All Available Rows from the Table batch strategy differs slightly depending on
            whether the origin is processing full tables or partitions within a table. <dl class="dl">
                
                    <dt class="dt dlterm">Multithreaded table processing</dt>

                    <dd class="dd">
                        <p class="p">When the origin performs multithreaded table processing for all tables,
                            each thread creates multiple batches of data from one table, until all
                            available rows are read from that table.</p>

                        <p class="p">The thread runs one SQL query for all batches created from the table.
                            Then, the thread switches to the next available table, running another
                            SQL query to read all available rows from that table.</p>

                        <p class="p">For example, let's say the origin has batch size of 100 and uses two
                            concurrent threads to read from four tables, each of which contains
                            1,000 rows. The first thread runs a SQL query to create 10 batches of
                            100 rows each from table1, while the second thread uses the same
                            strategy to read data from table2. </p>

                        <p class="p">When table1 and table2 are fully read, the threads switch to table3 and
                            table4 and complete the same process. When the first thread finishes
                            reading from table3, the thread switches back to the next available
                            table to read all available data from the last saved offset.</p>

                        <p class="p">The number of threads that can process the tables is limited by the
                            Number of Threads property for the origin. </p>

                        <p class="p">When the tables being processed use both table and partition processing,
                            the threads query the partitions as described below. For details on how
                            the tables and partitions rotate through the processing queue, see <a class="xref" href="MultiTableJDBCConsumer.html#concept_czt_ql2_r1b">Understanding the Processing Queue</a>.</p>

                    </dd>

                
                
                    <dt class="dt dlterm">Multithreaded partition processing</dt>

                    <dd class="dd"><p class="p">Multithreaded partition processing is similar to multithreaded table
                            processing, except that it works at a partition level.</p>
<p class="p">Each thread
                            creates multiple batches of data from one partition. The number of
                            batches that it creates and processes at one time is based on the
                            Batches from Result Set property. </p>
Each thread runs one SQL query for
                        the batches to be created from the partition. Then, the thread switches to
                        the next available partition, running another SQL query.<p class="p">For example, if
                            you set the Batches from Result Set property to 3, a thread runs a query
                            to create 3 batches of data from the partition that it processes. When
                            it completes processing the three batches, it becomes available to
                            process the next partition or table in the processing queue.</p>
<p class="p">The
                            number of threads that can process partitions for each table is limited
                            by the Number of Threads property for the origin and the Max Active
                            Partitions table property. </p>
<p class="p">For details on how the tables and
                            partitions rotate through the processing queue, see <a class="xref" href="MultiTableJDBCConsumer.html#concept_czt_ql2_r1b">Understanding the Processing Queue</a>.</p>
</dd>

                
            </dl>
</div>

 </div>

</div>
<div class="topic concept nested2" id="concept_amq_qg3_v1b">
 <h3 class="title topictitle3">Switch Tables</h3>

 <div class="body conbody">
  <div class="p">The Switch Tables batch strategy differs greatly depending on whether the origin performs full
            table or partition processing. The number of batches created and processed at one time
            is based on the Batches from Result Set property. <dl class="dl">
                
                    <dt class="dt dlterm">Multithreaded table processing</dt>

                    <dd class="dd">
                        <p class="p">When the origin performs multithreaded table processing for all tables,
                            each thread creates a set of batches from one table, and then switches
                            to the next available table to create the next set of batches.</p>

                        <div class="p">The thread runs an initial SQL query to create the first set of batches
                            from the table. The database caches the remaining rows in a result set
                            in the database for the same thread to access again, and then the thread
                            switches to the next available table. A table is available in the
                            following situations:<ul class="ul" id="concept_amq_qg3_v1b__ul_s1h_wg3_v1b">
                                <li class="li">The table does not have an open result set cache. In this case,
                                    the thread runs an initial SQL query to create the first batch,
                                    caching the remaining rows in a result set in the database.</li>

                                <li class="li">The table has an open result set cache created by that same
                                    thread. In this case, the thread creates the batch from the
                                    result set cache in the database rather than running another SQL
                                    query. </li>

                            </ul>
</div>

                        <p class="p">A table is not available when the table has an open result set cache
                            created by another thread. No other thread can read from that table
                            until the result set is closed. </p>

                        <div class="p">When you configure a switch table strategy, define the result set cache
                            size and the number of batches that a thread can create from the result
                            set. After a thread creates the configured number of batches, a
                            different thread can read from the table.<div class="note note"><span class="notetitle">Note:</span> By default, the origin
                                instructs the database to cache an unlimited number of result sets.
                                A thread can create an unlimited number of batches from that result
                                set.</div>
</div>

                        <p class="p">For example, let's say an origin has a batch size of 100 and uses two
                            concurrent threads and to read from four tables, each of which contains
                            10,000 rows. You set the result set cache size to 500 and set the number
                            of batches read from the result set to 5. </p>

                        <p class="p">Thread1 runs an SQL query on table1, which returns all 10,000 rows. The
                            thread creates a batch when it reads the first 100 rows. The next 400
                            rows are cached as a result set in the database. Since thread2 is
                            similarly processing table2, thread1 switches to the next available
                            table, table3, and repeats the same process. After creating a batch from
                            table3, thread1 switches back to table1 and retrieves the next batch of
                            rows from the result set that it previously cached in the database.</p>

                        <p class="p">After thread1 creates five batches using the result set cache for table1.
                            Thread1 then switches to the next available table. A different thread
                            runs an SQL query to read additional rows from table1, beginning from
                            the last saved offset.</p>

                        <p class="p">When the tables being processed use both table and partition processing,
                            the threads query the partitions as described below. For details on how
                            the tables and partitions rotate through the processing queue, see <a class="xref" href="MultiTableJDBCConsumer.html#concept_czt_ql2_r1b">Understanding the Processing Queue</a>.</p>

                    </dd>

                
                
                    <dt class="dt dlterm">Multithreaded partition processing</dt>

                    <dd class="dd">
                        <p class="p">Multithreaded partition processing is similar to multithreaded table
                            processing, with a twist - each thread creates a set of batches from one
                            partition for a table, then all partitions from the same table are moved
                            to the end of the processing queue. This allows the origin to switch to
                            the next available table.</p>

                        <p class="p">The behavior around caching the result set and the number of batches to
                            process from the result set is the same, but at a partition level. </p>

                        <p class="p">For examples of how tables and partitions rotate through the processing
                            queue, see <a class="xref" href="MultiTableJDBCConsumer.html#concept_czt_ql2_r1b">Understanding the Processing Queue</a>.</p>

                    </dd>

                
            </dl>
</div>

 </div>

</div>
</div>
<div class="topic concept nested1" id="concept_nff_2hx_4y">
 <h2 class="title topictitle2">Initial Table Order Strategy</h2>

 
 <div class="body conbody"><p class="shortdesc">You can define the initial order that the origin uses to read the tables.</p>

  <div class="p">Define
            one of the following initial table order strategies: <dl class="dl">
                
                              <dt class="dt dlterm">None</dt>

                              <dd class="dd">Reads the tables in the order that they are listed in the
                                    database.</dd>

                        
                
                              <dt class="dt dlterm">Alphabetical</dt>

                              <dd class="dd">Reads the tables in alphabetical order.</dd>

                        
                
                              <dt class="dt dlterm">Referential Constraints</dt>

                              <dd class="dd">Reads the tables based on the dependencies between the tables. The
                                    origin reads the parent table first, and then reads the child
                                    tables that refer to the parent table with a foreign key.</dd>

                              <dd class="dd">You cannot use the referential constraints order when the tables
                                    to be read have a cyclic dependency. When the origin detects a
                                    cyclic dependency, the pipeline fails to validate with the
                                    following
                                    error:<pre class="pre codeblock">JDBC_68 Tables referring to each other in a cyclic fashion.</pre>
</dd>

                              <dd class="dd">Note that the referential constraints order can cause pipeline
                                    validation or initialization to slow down because the origin has
                                    to sort the tables before reading them.</dd>

                        
            </dl>
</div>

        <p class="p">The origin uses this table order only for the initial reading of the tables. When threads
            switch back to previously read tables, they read from the next available table,
            regardless of the defined order.</p>

 </div>

</div>
<div class="topic concept nested1" id="concept_czt_ql2_r1b">
 <h2 class="title topictitle2">Understanding the Processing Queue</h2>

 <div class="body conbody">
  <p class="p">The JDBC Multitable Consumer origin
            maintains a virtual queue to determine the data to process from different tables. The
            queue includes each table defined in the origin. When a table is to be processed by
            partition, multiple partitions for the table are added to the queue, limited by the Max
            Partitions property. </p>

        <p class="p">The origin rotates and reorganizes the queue based on the Per Batch Strategy property.
            And it processes data from the queue with the threads specified in the Number of Threads
            property and the Batches from Result Set property.</p>

        <p class="p">Below are some scenarios to help clarify how the queue works.</p>

 </div>

<div class="topic concept nested2" id="concept_pqd_zyh_v1b">
 <h3 class="title topictitle3">Multiple Tables, No Partition Processing</h3>

 <div class="body conbody">
        <div class="p">Say you have tables A, B, C and D that you configure for table processing. When you start
            the pipeline, the origin adds all tables to the queue. If configured, the Initial Table
            Order Strategy advanced property can affect the order. Let's assume we have no
            referential constraints and use alphabetical order:<pre class="pre codeblock">A  B  C  D</pre>
When
            a thread becomes available, it processes data from the first table in the queue. The
            number of batches is based on the Batches from Result Set property. The processing of
            the tables depends on how you define the Per Batch Strategy property:<dl class="dl">
                
                    <dt class="dt dlterm">Process All Available Rows in the Table</dt>

                    <dd class="dd">With this batch strategy, threads do not start processing data in the next
                        table until all available data is processed for the preceding table. </dd>

                    <dd class="dd">
                        <p class="p">That is, table A remains at the front of the queue until all available
                            data is processed. Then processing begins on table B. Table A moves to
                            the back, remaining in the queue in case more data appears, as
                            follows:</p>

                        <pre class="pre codeblock">B  C  D  A  </pre>

                    </dd>

                
            </dl>
<dl class="dl">
                
                    <dt class="dt dlterm">Switch Tables</dt>

                    <dd class="dd">With this batch strategy, the order of the queue remains the same, but each
                        thread performs a SQL query to create a set of batches based on the Batches
                        from Result Set property. When it completes processing, it performs the same
                        process with the next table in the queue. </dd>

                    <dd class="dd">
                        <p class="p">After a thread takes a set of batches from table A, table A moves to the
                            back of the queue:</p>

                        <pre class="pre codeblock">B  C  D  A</pre>

                        <div class="p">The next thread takes a set of batches from table B. Then B moves to the
                            back of the queue:<pre class="pre codeblock">C  D  A  B  </pre>
</div>

                        <div class="p">So after processing 4 sets of batches, the queue looks like it did in the
                            beginning: <pre class="pre codeblock">A  B  C  D</pre>
</div>

                    </dd>

                
            </dl>
</div>

 </div>

</div>
<div class="topic concept nested2" id="concept_sjh_213_v1b">
 <h3 class="title topictitle3">Multiple Partitions, No Table Processing</h3>

 <div class="body conbody">
  <p class="p">Say you have table A, B, and C and all three tables are loaded up with lots of data to process.
            Tables A and B are configured with a maximum of 3 active partitions. And since table C
            has the largest volume of data, you allow an unlimited number of partitions. Again,
            let's use the alphabetical initial table ordering. </p>

        <div class="p">When you start the pipeline, each table is queued up with the maximum number of active
            partitions. And for table C, that means double the number of threads for the pipeline.
            So if we configure the pipeline for 4 threads, table C can have up to 8 partitions in
            the queue at any given time. So the initial queue looks like
            this:<pre class="pre codeblock">A1  A2  A3  B1  B2  B3  C1  C2  C3  C4  C5  C6  C7  C8 </pre>
A
            partition remains in the queue until the origin confirms that there is no more data in
            the partition. When a thread becomes available, it creates a set of batches from the
            first partition of the first table in the queue. The number of batches is based on the
            Batches from Result Set property. The order of tables and partitions in the queue
            depends on how you define the Per Batch Strategy, as follows:<dl class="dl">
                
                    <dt class="dt dlterm">Process All Available Rows in the Table</dt>

                    <dd class="dd">When processing partitions, this batch strategy retains the original order
                        of the queue, but rotates through the partitions as each thread processes a
                        set of batches. <div class="note note"><span class="notetitle">Note:</span> In practice, this means that rows from subsequent
                            tables can be processed before a previous table is completed, since
                            available threads continue to pick up partitions from the
                        queue.</div>
</dd>

                    <dd class="dd">For example, the four threads start processing on the first four partitions
                        in the queue: A1, A2, A3, and B1. This puts B2 at the front of the queue,
                        ready for the next available thread. And since the four partitions being
                        processed have additional data to process, they go to the back of the queue.
                        So processing of table B data begins before table A is fully processed. </dd>

                    <dd class="dd">
                        <p class="p">The rest of the partitions remain in the original order as follows:</p>

                        <pre class="pre codeblock">B2  B3  C1  C2  C3  C4  C5  C6  C7  C8  A1  A2  A3  B1</pre>

                    </dd>

                    <dd class="dd">After the four threads process another four sets of batches, the queue looks
                        like
                        this:<pre class="pre codeblock">C3  C4  C5  C6  C7  C8  A1  A2  A3  B1  B2  B3  C1  C2</pre>
</dd>

                
                
                    <dt class="dt dlterm">Switch Tables</dt>

                    <dd class="dd">When processing partitions, this batch strategy forces all subsequent,
                        consecutive partitions from the same table to the end of the queue each time
                        a thread processes a set of batches from a partition.</dd>

                    <dd class="dd">
                        <p class="p">Let's start again with the initial batch order:</p>

                        <pre class="pre codeblock">A1  A2  A3  B1  B2  B3  C1  C2  C3  C4  C5  C6  C7  C8 </pre>

                    </dd>

                    <dd class="dd">When a thread processes a set of batches from A1, it pushes the rest of the
                        table A partitions to the end of the queue. This queues up the next table,
                        table B, for processing. And since A1 still contains data, it takes the last
                        spot, as follows:
                        <pre class="pre codeblock">B1  B2  B3  C1  C2  C3  C4  C5  C6  C7  C8  A2  A3  A1</pre>
As
                        the second thread processes a set of batches from B1, the other B partitions
                        are sent to the back, and since B1 still contains data, it takes the last
                        spot as follows:
                        <pre class="pre codeblock">C1  C2  C3  C4  C5  C6  C7  C8  A2  A3  A1  B2  B3  B1</pre>
And
                        as the third thread takes a set of batches from C1, the rest of the C
                        partitions are pushed to the back, so the queue looks like
                        this:<pre class="pre codeblock">A2  A3  A1  B2  B3  B1  C2  C3  C4  C5  C6  C7  C8  C1</pre>
</dd>

                
            </dl>
</div>

 </div>

</div>
<div class="topic concept nested2" id="concept_tfm_513_v1b">
 <h3 class="title topictitle3">Both Partition and Table Processing</h3>

 <div class="body conbody">
  <p class="p">When processing a mix of full tables and partitioned tables, the queue basically behaves the
            same as when processing only partitions, with full tables being processed as partitioned
            tables with a single partition. Let's walk through it. </p>

        <div class="p">Say we have table A being processed without partitions, and table B configured with a
            maximum of 3 partitions, and table C with no limit. As in the example above, the
            pipeline has 4 threads to work with which allows 8 partitions to table C. Using the
            alphabetical initial table ordering, the initial queue looks like
            this:<pre class="pre codeblock">A  B1  B2  B3  C1  C2  C3  C4  C5  C6  C7  C8 </pre>
When a thread
            becomes available, it processes a set of batches from the first table or partition in
            the queue. The number of batches is based on the Batches from Result Set property. The
            order of the queue depends on how you define the Per Batch Strategy, as follows:<dl class="dl">
                
                    <dt class="dt dlterm">Process All Available Rows in the Table</dt>

                    <dd class="dd">With this batch strategy, the queue remains in the basic initial order and
                        rotates as each thread claims a set of batches from the next table or
                        partition. The unpartitioned table A is processed like a table with a single
                        partition. <p class="p">Note that unpartitioned tables are not processed in full when
                            they move to the front of the queue. For this behavior, configure all
                            tables to be processed without partitions. Or, set the Batches from
                            Result Set property to -1. </p>
<p class="p">When the pipeline starts, the 4
                            threads process a set of batches from the A table and from partitions
                            B1, B2, and B3. Since the table and partitions all still contain data,
                            they then move to the end of the queue as follows:
                            </p>
<pre class="pre codeblock">C1  C2  C3  C4  C5  C6  C7  C8  A  B1  B2  B3 </pre>
<div class="p">As
                            each thread completes processing, it processes a set of batches from the
                            front of the queue. After each of the 4 threads takes another set of
                            batches, the queue looks like
                            this:<pre class="pre codeblock">C5  C6  C7  C8  A  B1  B2  B3  C1  C2  C3  C4 </pre>
</div>
</dd>

                
                
                    <dt class="dt dlterm">Switch Tables</dt>

                    <dd class="dd">When processing tables and partitions, this batch strategy forces all
                        subsequent, consecutive partitions from the same table to the end of the
                        queue. And it treats unpartitioned tables as a table with a single
                        partition. As a result, the queue rotation is a simplified version of
                        processing only partitioned tables. <p class="p">So we have this initial order:</p>
<div class="p">
                            <pre class="pre codeblock">A  B1  B2  B3  C1  C2  C3  C4  C5  C6  C7  C8 </pre>

                        </div>
<div class="p">The first thread processes a set of batches from table A, and since
                            there are no related partitions, it simply goes to the end of the queue:
                            <pre class="pre codeblock">B1  B2  B3  C1  C2  C3  C4  C5  C6  C7  C8  A</pre>
</div>
<div class="p">The
                            second thread processes a set of batches from B1, pushes the rest of the
                            table B partitions to the end of the queue, and B1 lands at the end
                            because it contains more data to be
                            processed:<pre class="pre codeblock">C1  C2  C3  C4  C5  C6  C7  C8  A  B2  B3  B1</pre>
</div>
<div class="p">The
                            third thread processes a set of batches from C1, pushes the rest of the
                            table C partitions to the end, and C1 takes the last slot:
                            <pre class="pre codeblock">A  B2  B3  B1  C2  C3  C4  C5  C6  C7  C8  C1</pre>
</div>
<div class="p">And
                            then the fourth thread processes another set of batches from table A and
                            moves A to the end of the
                            queue:<pre class="pre codeblock">B2  B3  B1  C2  C3  C4  C5  C6  C7  C8  C1  A</pre>
</div>
</dd>

                
            </dl>
</div>

 </div>

</div>
</div>
<div class="topic concept nested1" id="concept_xrx_11y_4y">
 <h2 class="title topictitle2">JDBC Header Attributes</h2>

 <div class="body conbody">
  <p class="p">The JDBC
            Multitable Consumer origin generates JDBC record header attributes that provide
            additional information about each record, such as the original data type of a field or
            the source tables for the record. The origin receives these details from the JDBC
            driver. </p>

     <p class="p">You can use the record:attribute or record:attributeOrDefault functions to
            access the information in the attributes. For more information about working with record
            header attributes, see <a class="xref" href="../Pipeline_Design/RecordHeaderAttributes.html#concept_rd2_ghz_dz">Working with Header Attributes</a>.</p>

        <p class="p">JDBC record header attributes include a "jdbc" prefix to differentiate the JDBC
            attributes from other record header attributes.</p>

        <div class="p">The origin can provide the following JDBC header attributes:
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="concept_xrx_11y_4y__table_p1c_q5c_kw" class="table" frame="border" border="1" rules="all">
                    
                    
                    <thead class="thead" align="left">
                        <tr>
                            <th class="entry" valign="top" width="40%" id="d326216e1348">JDBC Header Attribute</th>

                            <th class="entry" valign="top" width="60%" id="d326216e1351">Description</th>

                        </tr>

                    </thead>

                    <tbody class="tbody">
                        <tr>
                            <td class="entry" valign="top" width="40%" headers="d326216e1348 "> jdbc.tables</td>

                            <td class="entry" valign="top" width="60%" headers="d326216e1351 ">Provides a comma-separated list of source
                                tables for the fields in the record.<div class="note note"><span class="notetitle">Note:</span> Not all JDBC drivers
                                    provide this information.</div>
<p class="p"><span class="ph">Oracle uses all caps for schema, table, and column names by
                        default. Names can be lower- or mixed-case only if the schema, table, or
                        column was created with quotation marks around the name.</span></p>
</td>

                        </tr>

                        <tr>
                            <td class="entry" valign="top" width="40%" headers="d326216e1348 ">jdbc.partition</td>

                            <td class="entry" valign="top" width="60%" headers="d326216e1351 ">Provides the full offset key for the partition that produced the
                                record</td>

                        </tr>

                        <tr>
                            <td class="entry" valign="top" width="40%" headers="d326216e1348 ">jdbc.threadNumber</td>

                            <td class="entry" valign="top" width="60%" headers="d326216e1351 ">Provides the number of the thread that produced the record.
                            </td>

                        </tr>

                        <tr>
                            <td class="entry" valign="top" width="40%" headers="d326216e1348 ">jdbc.&lt;column name&gt;.jdbcType</td>

                            <td class="entry" valign="top" width="60%" headers="d326216e1351 ">Provides the original SQL data type for each
                                field in the record.</td>

                        </tr>

                        <tr>
                            <td class="entry" valign="top" width="40%" headers="d326216e1348 ">jdbc.&lt;column name&gt;.precision</td>

                            <td class="entry" valign="top" width="60%" headers="d326216e1351 ">Provides the original precision for all
                                numeric and decimal fields. </td>

                        </tr>

                        <tr>
                            <td class="entry" valign="top" width="40%" headers="d326216e1348 ">jdbc.&lt;column name&gt;.scale</td>

                            <td class="entry" valign="top" width="60%" headers="d326216e1351 ">Provides the original scale for all numeric
                                and decimal fields. </td>

                        </tr>

                    </tbody>

                </table>
</div>
</div>

     
 </div>

</div>
<div class="topic concept nested1" id="concept_wjj_gzs_kz">
 <h2 class="title topictitle2">Event Generation</h2>

    <div class="body conbody">
        <p class="p">The JDBC
            Multitable Consumer origin <span class="ph">can generate events that you can use in an event stream. When you
                              enable event generation, the origin generates an event when it
                              completes processing the data returned by the specified</span> queries for all tables.</p>

        <div class="p">JDBC Multitable Consumer events can be used in any logical way. For example: <ul class="ul" id="concept_wjj_gzs_kz__ul_xjk_kf1_4z">
                <li class="li">With the Pipeline Finisher executor to
                              stop the pipeline and transition the pipeline to a Finished state when
                              the origin completes processing available data.<p class="p">When you restart a
                                    pipeline stopped by the Pipeline Finisher executor, the origin
                                    continues processing from the last-saved offset unless you reset
                                    the origin.</p>
<p class="p">For an example, see <a class="xref" href="../Event_Handling/EventFramework-Title.html#concept_kff_ykv_lz">Case Study: Stop the Pipeline</a>.</p>
</li>

                <li class="li">With the Email executor to send a custom email
                              after receiving an event.<p class="p">For an example, see <a class="xref" href="../Event_Handling/EventFramework-Title.html#concept_t2t_lp5_xz">Case Study: Sending Email</a>.</p>
</li>

            </ul>
<ul class="ul" id="concept_wjj_gzs_kz__ul_fjm_fhs_kz">
                        <li class="li">
                              <p class="p">With a destination to store information about completed queries. </p>

                              <p class="p">For an example, see <a class="xref" href="../Event_Handling/EventFramework-Title.html#concept_ocb_nnl_px">Case Study: Event Storage</a>.</p>

                        </li>

                  </ul>
</div>

        <p class="p"><span class="ph">For more information about dataflow
                        triggers and the event framework, see <a class="xref" href="../Event_Handling/EventFramework-Title.html#concept_cph_5h4_lx">Dataflow Triggers Overview</a>.</span></p>

    </div>

<div class="topic concept nested2" id="concept_h4j_4zs_kz">
 <h3 class="title topictitle3">Event Record</h3>

    <div class="body conbody">
        <div class="p">Event records generated by JDBC
            Multitable Consumer origin have the following event-related record header
                attributes:
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="concept_h4j_4zs_kz__EventHead-NoMoreData-table" class="table" frame="border" border="1" rules="all">
                    
                    
                    <thead class="thead" align="left">
                        <tr>
                            <th class="entry" valign="top" width="30%" id="d326216e1527">Record Header Attribute</th>

                            <th class="entry" valign="top" width="70%" id="d326216e1530">Description</th>

                        </tr>

                    </thead>

                    <tbody class="tbody">
                        <tr>
                            <td class="entry" valign="top" width="30%" headers="d326216e1527 ">sdc.event.type</td>

                            <td class="entry" valign="top" width="70%" headers="d326216e1530 ">Event type. Uses the following type:<ul class="ul" id="concept_h4j_4zs_kz__ul_f4w_xrs_kz">
                                    <li class="li" id="concept_h4j_4zs_kz__noMoreData-bullet">no-more-data - Generated when the
                                        origin completes processing all data returned by the queries
                                        for all tables.</li>

                                </ul>
</td>

                        </tr>

                        <tr>
       <td class="entry" valign="top" width="30%" headers="d326216e1527 ">sdc.event.version</td>

       <td class="entry" valign="top" width="70%" headers="d326216e1530 ">An integer that indicates the version of the event record type.</td>

      </tr>

                        <tr>
       <td class="entry" valign="top" width="30%" headers="d326216e1527 ">sdc.event.creation_timestamp</td>

       <td class="entry" id="concept_h4j_4zs_kz__d42622e2086" valign="top" width="70%" headers="d326216e1530 ">Epoch timestamp when the stage created the event.
       </td>

      </tr>

                    </tbody>

                </table>
</div>
</div>

        <p class="p">The no-more-data event record includes no record fields.</p>

    </div>

</div>
</div>
<div class="topic task nested1" id="task_kst_m4w_4y">
    <h2 class="title topictitle2">Configuring a JDBC Multitable Consumer</h2>

    <div class="body taskbody">
        <div class="section context">
            <p class="p">Configure a JDBC Multitable
                Consumer origin to use a JDBC connection to read database data from multiple tables.
            </p>

        </div>

        <ol class="ol steps"><li class="li step stepexpand">
                <span class="ph cmd">In the Properties panel, on the <span class="keyword wintitle">General</span> tab, configure the
                    following properties:</span>
                <div class="itemgroup info">
                    
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="task_kst_m4w_4y__table_ac1_hss_5x" class="table" frame="border" border="1" rules="all">
                            
                            
                            <thead class="thead" align="left">
                                <tr>
                                    <th class="entry" valign="top" width="27.27272727272727%" id="d326216e1620">General Property</th>

                                    <th class="entry" valign="top" width="72.72727272727273%" id="d326216e1623">Description</th>

                                </tr>

                            </thead>

                            <tbody class="tbody">
                                <tr>
       <td class="entry" valign="top" width="27.27272727272727%" headers="d326216e1620 ">Name</td>

       <td class="entry" valign="top" width="72.72727272727273%" headers="d326216e1623 ">Stage name.</td>

      </tr>

                                <tr>
       <td class="entry" valign="top" width="27.27272727272727%" headers="d326216e1620 ">Description</td>

       <td class="entry" valign="top" width="72.72727272727273%" headers="d326216e1623 ">Optional description.</td>

      </tr>

                                <tr>
                                    <td class="entry" valign="top" width="27.27272727272727%" headers="d326216e1620 ">Produce Events <a class="xref" href="MultiTableJDBCConsumer.html#concept_wjj_gzs_kz">
                                            <img class="image" id="task_kst_m4w_4y__image_plp_tp2_px" src="../Graphics/icon_moreInfo.png" height="12" width="12" /></a></td>

                                    <td class="entry" valign="top" width="72.72727272727273%" headers="d326216e1623 ">Generates event records when events occur. Use for event
        handling. <a class="xref" href="../Event_Handling/EventFramework-Title.html#concept_cph_5h4_lx">
         <img class="image" id="task_kst_m4w_4y__d42622e794" src="../Reusable_Content/../Graphics/icon_moreInfo.png" height="12" width="12" /></a></td>

                                </tr>

                                <tr>
       <td class="entry" valign="top" width="27.27272727272727%" headers="d326216e1620 ">On Record Error <a class="xref" href="../Pipeline_Design/ErrorHandling.html#concept_atr_j4y_5r">
         <img class="image" id="task_kst_m4w_4y__d42622e803" src="../Reusable_Content/../Graphics/icon_moreInfo.png" height="12" width="12" /></a></td>

       <td class="entry" valign="top" width="72.72727272727273%" headers="d326216e1623 ">Error record handling for the stage: <ul class="ul" id="task_kst_m4w_4y__d42622e807">
         <li class="li">Discard - Discards the record.</li>

         <li class="li">Send to Error - Sends the record to the pipeline for error handling.</li>

         <li class="li">Stop Pipeline - Stops the pipeline. </li>

        </ul>
</td>

      </tr>

                            </tbody>

                        </table>
</div>

                </div>
            </li>
<li class="li step stepexpand">
                <span class="ph cmd">On the <span class="keyword wintitle">JDBC</span> tab, configure the following properties:</span>
                <div class="itemgroup info">
                    
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="task_kst_m4w_4y__table_zpr_xs2_py" class="table" frame="border" border="1" rules="all">
                            
                            
                            <thead class="thead" align="left">
                                <tr>
                                    <th class="entry" valign="top" width="22.22222222222222%" id="d326216e1716">JDBC Property</th>

                                    <th class="entry" valign="top" width="77.77777777777779%" id="d326216e1719">Description</th>

                                </tr>

                            </thead>

                            <tbody class="tbody">
                                <tr>
       <td class="entry" valign="top" width="22.22222222222222%" headers="d326216e1716 ">JDBC Connection String</td>

       <td class="entry" valign="top" width="77.77777777777779%" headers="d326216e1719 ">Connection string to use to connect to the database.<p class="p">Some databases, such as
         Postgres, require the schema in the connection string. Use the connection string format
         required by the database.</p>
</td>

      </tr>

                                <tr>
       <td class="entry" valign="top" width="22.22222222222222%" headers="d326216e1716 ">Use Credentials</td>

       <td class="entry" valign="top" width="77.77777777777779%" headers="d326216e1719 ">Enables entering credentials on the Credentials tab. Use when you do not include
        credentials in the JDBC connection string.</td>

      </tr>

                                <tr>
                                    <td class="entry" valign="top" width="22.22222222222222%" headers="d326216e1716 ">Queries per Second</td>

                                    <td class="entry" valign="top" width="77.77777777777779%" headers="d326216e1719 ">Maximum number of queries to run in a second across all
                                        partitions and tables. Use 0 for no limit.<p class="p">Default is 10.
                                        </p>
</td>

                                </tr>

                                <tr>
                                    <td class="entry" valign="top" width="22.22222222222222%" headers="d326216e1716 ">Number of Threads <a class="xref" href="MultiTableJDBCConsumer.html#concept_tz5_fw5_gz"><img class="image" id="task_kst_m4w_4y__image_r2s_8lq_fs" src="../Graphics/icon_moreInfo.png" height="12" width="12" />
                                        </a></td>

                                    <td class="entry" valign="top" width="77.77777777777779%" headers="d326216e1719 ">Number of threads the origin generates and uses for
                                        multithreaded processing.<p class="p">Configure the Maximum Pool Size
                                            property on the Advanced tab to be equal to or greater
                                            than this value.</p>
</td>

                                </tr>

                                <tr>
                                    <td class="entry" valign="top" width="22.22222222222222%" headers="d326216e1716 ">Per Batch Strategy <a class="xref" href="MultiTableJDBCConsumer.html#concept_n5t_zgx_4y"><img class="image" id="task_kst_m4w_4y__image_r3s_7rq_ds" src="../Graphics/icon_moreInfo.png" height="12" width="12" />
                                        </a></td>

                                    <td class="entry" valign="top" width="77.77777777777779%" headers="d326216e1719 ">Strategy to create each batch of data:<ul class="ul" id="task_kst_m4w_4y__ul_fk4_11f_py">
                                            <li class="li">Switch Tables - When performing only multithreaded
                                                table processing, each thread creates a batch of
                                                data from one table, and then switches to the next
                                                available table to create the next batch. Define the
                                                Result Set Cache Size and the Batches from Result
                                                Set properties when you configure a switch tables
                                                strategy.</li>

                                            <li class="li">Process All Available Rows from the Table - When
                                                performing only multithreaded table processing, each
                                                thread creates multiple batches of data from one
                                                table, until all available rows are read from that
                                                table.</li>

                                        </ul>
<p class="p">When performing multithreaded partition processing
                                            or a mix of table and partition processing, the behavior
                                            for each batch strategy is more complicated. For
                                            details, see <a class="xref" href="MultiTableJDBCConsumer.html#concept_czt_ql2_r1b">Understanding the Processing Queue</a>.</p>
</td>

                                </tr>

                                <tr>
       <td class="entry" valign="top" width="22.22222222222222%" headers="d326216e1716 ">Max Batch Size (records)</td>

       <td class="entry" valign="top" width="77.77777777777779%" headers="d326216e1719 ">Maximum number of records to include in a batch.</td>

      </tr>

                                <tr>
       <td class="entry" valign="top" width="22.22222222222222%" headers="d326216e1716 ">Batches from Result Set <a class="xref" href="MultiTableJDBCConsumer.html#concept_n5t_zgx_4y"><img class="image" id="task_kst_m4w_4y__d42622e2344" src="../Reusable_Content/../Graphics/icon_moreInfo.png" height="12" width="12" />
        </a></td>

       <td class="entry" id="task_kst_m4w_4y__d42622e2347" valign="top" width="77.77777777777779%" headers="d326216e1719 ">Number of batches to create from the result set. After a
        thread creates this number of batches, the database closes the result set and then another
        thread can read from the same table.<p class="p">Use a positive integer to set a limit on the number
         of batches created from the result set. Use -1 to opt out of this property.</p>
<p class="p">By
         default, the origin creates an unlimited number of batches from the result set, keeping the
         result set open as long as possible.</p>
</td>

      </tr>

                                <tr>
       <td class="entry" valign="top" width="22.22222222222222%" headers="d326216e1716 ">Result Set Cache Size <a class="xref" href="MultiTableJDBCConsumer.html#concept_n5t_zgx_4y"><img class="image" id="task_kst_m4w_4y__d42622e2360" src="../Reusable_Content/../Graphics/icon_moreInfo.png" height="12" width="12" />
        </a></td>

       <td class="entry" id="task_kst_m4w_4y__d42622e2363" valign="top" width="77.77777777777779%" headers="d326216e1719 ">Number of result sets to cache in the database. Use a
        positive integer to set a limit on the number of cached result sets. Use -1 to opt out of
        this property.<p class="p">By default, the origin caches an unlimited number of result
        sets.</p>
</td>

      </tr>

                                <tr>
       <td class="entry" valign="top" width="22.22222222222222%" headers="d326216e1716 ">Max Clob Size (characters)</td>

       <td class="entry" valign="top" width="77.77777777777779%" headers="d326216e1719 ">Maximum number of characters to be read in a Clob field. Larger data is
        truncated.</td>

      </tr>

                                <tr>
       <td class="entry" valign="top" width="22.22222222222222%" headers="d326216e1716 ">Max Blob Size (bytes)</td>

       <td class="entry" valign="top" width="77.77777777777779%" headers="d326216e1719 ">
        <p class="p">Maximum number of bytes to be read in a Blob field. </p>

       </td>

      </tr>

                                <tr>
       <td class="entry" valign="top" width="22.22222222222222%" headers="d326216e1716 ">Number of Retries on SQL Error</td>

       <td class="entry" valign="top" width="77.77777777777779%" headers="d326216e1719 ">Number of times a thread tries to read a batch of data after receiving an SQL error.
        After a thread retries this number of times, the thread handles the error based on the error
        handling configured for the origin.<p class="p">Use to handle transient network or connection issues
         that prevent a thread from reading a batch of data.</p>
<p class="p">Default is 0. </p>
</td>

      </tr>

                                <tr>
       <td class="entry" valign="top" width="22.22222222222222%" headers="d326216e1716 ">Data Time Zone</td>

       <td class="entry" valign="top" width="77.77777777777779%" headers="d326216e1719 ">Time zone to use to evaluate datetime-based offset column conditions. </td>

      </tr>

                                <tr>
                                    <td class="entry" valign="top" width="22.22222222222222%" headers="d326216e1716 ">Quote Character</td>

                                    <td class="entry" valign="top" width="77.77777777777779%" headers="d326216e1719 ">Quote character to use around schema, table, and column
                                        names in the query. Select the character used by the
                                        database to allow for lower case, mixed-case, or special
                                        characters in schema, table, or column names:<ul class="ul" id="task_kst_m4w_4y__ul_xrg_53s_pz">
                                            <li class="li">None - Uses no character around names in the query.
                                                For example: <samp class="ph codeph">select * from mySchema.myTable
                                                  order by myOffsetColumn</samp>.</li>

                                            <li class="li">Backtick - Uses a backtick around names in the
                                                query. For example: <samp class="ph codeph">select * from
                                                  `mySchema`.`myTable` order by
                                                  `myOffsetColumn`</samp>.</li>

                                            <li class="li">Double Quotes - Uses double quotes around names in
                                                the query. For example: <samp class="ph codeph">select * from
                                                  "mySchema"."myTable" order by
                                                  "myOffsetColumn"</samp>.</li>

                                        </ul>
</td>

                                </tr>

                                <tr>
       <td class="entry" id="task_kst_m4w_4y__d42622e2415" valign="top" width="22.22222222222222%" headers="d326216e1716 ">Fetch Size</td>

       <td class="entry" valign="top" width="77.77777777777779%" headers="d326216e1719 "><span class="ph" id="task_kst_m4w_4y__d42622e2419">Maximum number of rows to fetch and store in memory on the <span class="ph">Data
                  Collector</span> machine.
         The size cannot be zero.</span><p class="p"><span class="ph" id="task_kst_m4w_4y__d42622e2424">Default is 1,000.</span></p>
<div class="p">
         <div class="note note"><span class="notetitle">Note:</span> By default, MySQL fetches and stores the complete result set in memory on the <span class="ph">Data
                  Collector</span>
          machine. If the result sets have a large number of rows or large values that exceed
          available memory, specify a fetch size of <samp class="ph codeph">Integer.MIN_VALUE</samp> so that MySQL
          streams the results to the <span class="ph">Data
                  Collector</span> machine
          one row at a time.</div>

        </div>
<p class="p">For more information about configuring a fetch size, see your database
         documentation.</p>
</td>

      </tr>

                                <tr>
       <td class="entry" valign="top" width="22.22222222222222%" headers="d326216e1716 ">Additional JDBC Configuration Properties</td>

       <td class="entry" valign="top" width="77.77777777777779%" headers="d326216e1719 ">Additional JDBC configuration properties to use. To add properties, click
         <span class="ph uicontrol">Add</span> and define the JDBC property name and value. <p class="p">Use the property
         names and values as expected by JDBC. </p>
</td>

      </tr>

                            </tbody>

                        </table>
</div>

                </div>
            </li>
<li class="li step stepexpand">
                <span class="ph cmd">On the <span class="keyword wintitle">Tables</span> tab, define one or more table
                    configurations. Using <a class="xref" href="../Pipeline_Configuration/SimpleBulkEdit.html#concept_alb_b3y_cbb">simple or bulk edit mode</a>, click the <span class="ph uicontrol">Add</span> icon
                    to define another table configuration.</span>
                <div class="itemgroup info">Configure the following properties for each table configuration:
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="task_kst_m4w_4y__table_cvl_qp5_qy" class="table" frame="border" border="1" rules="all">
                            
                            
                            <thead class="thead" align="left">
                                <tr>
                                    <th class="entry" valign="top" width="22.22222222222222%" id="d326216e1994">Tables Property <a class="xref" href="MultiTableJDBCConsumer.html#concept_rx3_3hx_4y" title="You define the group of tables that the JDBC Multitable Consumer origin reads by defining a table name pattern for the table configuration. The origin reads all tables whose names match the pattern. The JDBC Multitable Consumer origin uses an offset column and initial offset value to determine where to start reading data within tables and partitions."><img class="image" id="task_kst_m4w_4y__image_hvl_qp2_qy" src="../Graphics/icon_moreInfo.png" height="12" width="12" />
                                        </a></th>

                                    <th class="entry" valign="top" width="77.77777777777779%" id="d326216e2004">Description</th>

                                </tr>

                            </thead>

                            <tbody class="tbody">
                                <tr>
                                    <td class="entry" valign="top" width="22.22222222222222%" headers="d326216e1994 ">Schema Name</td>

                                    <td class="entry" valign="top" width="77.77777777777779%" headers="d326216e2004 ">Name of the schema to use for this table configuration.
                                        Required for Oracle tables. <p class="p"><span class="ph">Oracle uses all caps for schema, table, and column names by
                        default. Names can be lower- or mixed-case only if the schema, table, or
                        column was created with quotation marks around the name.</span></p>
</td>

                                </tr>

                                <tr>
                                    <td class="entry" valign="top" width="22.22222222222222%" headers="d326216e1994 ">Table Name Pattern <a class="xref" href="MultiTableJDBCConsumer.html#concept_ank_41x_4y" title="You define the group of tables that the JDBC Multitable Consumer origin reads by defining a table name pattern for the table configuration. The origin reads all tables whose names match the pattern."><img class="image" id="task_kst_m4w_4y__image_evl_qp5_qy" src="../Graphics/icon_moreInfo.png" height="12" width="12" />
                                        </a></td>

                                    <td class="entry" valign="top" width="77.77777777777779%" headers="d326216e2004 ">Pattern of the table names to read for this table
                                        configuration. Use the SQL LIKE syntax to define the
                                        pattern. <div class="note note"><span class="notetitle">Note:</span> <span class="ph">Oracle uses all caps for schema, table, and column names by
                        default. Names can be lower- or mixed-case only if the schema, table, or
                        column was created with quotation marks around the name.</span></div>
<p class="p">Default is the percentage wildcard (%) which
                                            matches all tables in the schema.</p>
</td>

                                </tr>

                                <tr>
                                    <td class="entry" valign="top" width="22.22222222222222%" headers="d326216e1994 ">Table Exclusion Pattern <a class="xref" href="MultiTableJDBCConsumer.html#concept_ank_41x_4y" title="You define the group of tables that the JDBC Multitable Consumer origin reads by defining a table name pattern for the table configuration. The origin reads all tables whose names match the pattern."><img class="image" id="task_kst_m4w_4y__image_fvl_qp5_qy" src="../Graphics/icon_moreInfo.png" height="12" width="12" />
                                        </a></td>

                                    <td class="entry" valign="top" width="77.77777777777779%" headers="d326216e2004 ">Pattern of the table names to exclude from being read for
                                        this table configuration. Use a Java-based regular
                                        expression, or regex, to define the pattern.<p class="p">Leave empty
                                            if you do not need to exclude any tables.</p>
</td>

                                </tr>

                                <tr>
                                    <td class="entry" valign="top" width="22.22222222222222%" headers="d326216e1994 ">Override Offset Columns <a class="xref" href="MultiTableJDBCConsumer.html#concept_yfx_mhx_4y" title="The JDBC Multitable Consumer origin uses an offset column and initial offset value to determine where to start reading data within tables and partitions."><img class="image" id="task_kst_m4w_4y__image_gvl_qp5_qy" src="../Graphics/icon_moreInfo.png" height="12" width="12" />
                                        </a></td>

                                    <td class="entry" valign="top" width="77.77777777777779%" headers="d326216e2004 ">Determines whether to use the primary keys or other
                                        columns as the offset columns for this table configuration.
                                            <p class="p">Select to override the primary keys and define other
                                            offset columns. Clear to use existing primary keys as
                                            the offset columns. </p>
<p class="p">To perform multithreaded
                                            partition processing on a table with multiple key
                                            columns or a key column with unsupported data types,
                                            select this option and specify a valid offset column.
                                            For more information about partition processing
                                            requirements, see <a class="xref" href="MultiTableJDBCConsumer.html#concept_c54_hj1_q1b">Partition Processing Requirements</a>.</p>
</td>

                                </tr>

                                <tr>
                                    <td class="entry" valign="top" width="22.22222222222222%" headers="d326216e1994 ">Offset Columns</td>

                                    <td class="entry" valign="top" width="77.77777777777779%" headers="d326216e2004 ">The offset columns to use. <p class="p">As a best practice, an
                                            offset column should be an incremental and unique
                                            column. Having an index on this column is strongly
                                            encouraged since the underlying query uses an ORDER BY
                                            and inequality operators on this column.</p>
</td>

                                </tr>

                                <tr>
                                    <td class="entry" valign="top" width="22.22222222222222%" headers="d326216e1994 ">Initial Offset <a class="xref" href="MultiTableJDBCConsumer.html#concept_yfx_mhx_4y" title="The JDBC Multitable Consumer origin uses an offset column and initial offset value to determine where to start reading data within tables and partitions."><img class="image" id="task_kst_m4w_4y__image_hvl_qp5_qy" src="../Graphics/icon_moreInfo.png" height="12" width="12" />
                                        </a></td>

                                    <td class="entry" valign="top" width="77.77777777777779%" headers="d326216e2004 ">Offset value to use for this table configuration when the
                                        pipeline starts. Enter the primary key name or offset column
                                        name and value. For Datetime columns, enter a Long
                                            value.<p class="p">When you define multiple offset columns, you
                                            must define an initial offset value for each column, in
                                            the same order that the columns are defined.</p>
</td>

                                </tr>

                                <tr>
                                    <td class="entry" valign="top" width="22.22222222222222%" headers="d326216e1994 ">Enable Non-Incremental Load</td>

                                    <td class="entry" valign="top" width="77.77777777777779%" headers="d326216e2004 ">Enables <a class="xref" href="MultiTableJDBCConsumer.html#concept_xwr_bhm_nbb">non-incremental processing</a> of tables that do not
                                        include a primary key or offset column. Do not use when
                                        requiring multithreaded partition processing. </td>

                                </tr>

                                <tr>
                                    <td class="entry" valign="top" width="22.22222222222222%" headers="d326216e1994 ">Multithreaded Partition Processing Mode</td>

                                    <td class="entry" valign="top" width="77.77777777777779%" headers="d326216e2004 ">Determines how the origin performs multithreaded
                                        processing. Select one of the following options:<ul class="ul" id="task_kst_m4w_4y__ul_btn_wfj_t1b">
                                            <li class="li">Off - The origin performs <a class="xref" href="MultiTableJDBCConsumer.html#concept_tz5_fw5_gz">multithreaded table processing</a>.<p class="p">Can be
                                                  used to perform <a class="xref" href="https://docs.google.com/document/d/1Eea8KPKhHz8OdCl0sp0zmRJeeYgT9w7iVOJe-TbeEjw/edit#heading=h.kdebto8fxfkr" target="_blank">non-incremental
                                                  processing</a> of tables without key or offset
                                                  columns.</p>
</li>

                                            <li class="li">On (Best Effort) - The origin performs <a class="xref" href="MultiTableJDBCConsumer.html#concept_gvy_yws_p1b">multithreaded partition processing</a> for all
                                                tables that meet the <a class="xref" href="MultiTableJDBCConsumer.html#concept_c54_hj1_q1b">partition processing requirements</a> and
                                                performs multithreaded table partitioning tables
                                                with multiple key or offset columns.<p class="p">Can be used
                                                  to perform <a class="xref" href="https://docs.google.com/document/d/1Eea8KPKhHz8OdCl0sp0zmRJeeYgT9w7iVOJe-TbeEjw/edit#heading=h.kdebto8fxfkr" target="_blank">non-incremental
                                                  processing</a> of tables without key or offset
                                                  columns.</p>
</li>

                                            <li class="li">On (Required) - The origin performs multithreaded
                                                partition processing for all tables. <p class="p">Generates an
                                                  error if the table configuration includes tables
                                                  that do not meet the partition processing
                                                  requirements.</p>
</li>

                                        </ul>
</td>

                                </tr>

                                <tr>
                                    <td class="entry" valign="top" width="22.22222222222222%" headers="d326216e1994 ">Partition Size</td>

                                    <td class="entry" valign="top" width="77.77777777777779%" headers="d326216e2004 ">The range of values in the offset column to use to create
                                        partitions. <p class="p">If the offset column is a Datetime column,
                                            provide the partition size in milliseconds. For example,
                                            to create a partition for every hour, enter
                                        3600000.</p>
</td>

                                </tr>

                                <tr>
                                    <td class="entry" valign="top" width="22.22222222222222%" headers="d326216e1994 ">Max Partitions</td>

                                    <td class="entry" valign="top" width="77.77777777777779%" headers="d326216e2004 ">The maximum number of partitions to be maintained or
                                        processed at one time for a single table. Adjusting this
                                        value can increase throughput depending on various factors,
                                        including the machine running <span class="ph">Data
                  Collector</span> and the database server type and capacity.<p class="p">The minimum
                                            positive value is 2, to ensure the origin can make
                                            progress through the partitions.</p>
<p class="p">Enter -1 to use
                                            the default behavior, allowing the origin to create up
                                            to twice as many partitions for each table as threads
                                            used by the origin. Best practice is to start with the
                                            default behavior and adjust to tune
                                        performance.</p>
</td>

                                </tr>

                                <tr>
                                    <td class="entry" valign="top" width="22.22222222222222%" headers="d326216e1994 ">Offset Column Conditions <a class="xref" href="MultiTableJDBCConsumer.html#concept_yfx_mhx_4y" title="The JDBC Multitable Consumer origin uses an offset column and initial offset value to determine where to start reading data within tables and partitions."><img class="image" id="task_kst_m4w_4y__image_ivl_qp5_qy" src="../Graphics/icon_moreInfo.png" height="12" width="12" />
                                        </a></td>

                                    <td class="entry" valign="top" width="77.77777777777779%" headers="d326216e2004 ">Additional conditions that the origin uses to determine
                                        where to start reading data for this table configuration.
                                        The origin adds the defined condition to the WHERE clause of
                                        the SQL query. <p class="p">Use the expression language to define the
                                            conditions. For example, you can use the offset:column
                                            function to compare the value of an offset
                                        column.</p>
</td>

                                </tr>

                            </tbody>

                        </table>
</div>
</div>
            </li>
<li class="li step stepexpand">
                <span class="ph cmd">To enter JDBC credentials separately from the JDBC connection string, on the
                        <span class="ph uicontrol">Credentials</span> tab, configure the following
                    properties:</span>
                <div class="itemgroup info">
                    
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="task_kst_m4w_4y__d42825e3611" class="table" frame="border" border="1" rules="all">
                            
                            
                            <thead class="thead" align="left">
                                <tr>
                                    <th class="entry" valign="top" width="30%" id="d326216e2246">Credentials Property</th>

                                    <th class="entry" valign="top" width="70%" id="d326216e2249">Description</th>

                                </tr>

                            </thead>

                            <tbody class="tbody">
                                <tr>
                                    <td class="entry" valign="top" width="30%" headers="d326216e2246 ">Username</td>

                                    <td class="entry" valign="top" width="70%" headers="d326216e2249 ">User name for the JDBC connection.</td>

                                </tr>

                                <tr id="task_kst_m4w_4y__d42825e3642">
                                    <td class="entry" valign="top" width="30%" headers="d326216e2246 ">Password</td>

                                    <td class="entry" valign="top" width="70%" headers="d326216e2249 ">Password for the JDBC account.<div class="note tip"><span class="tiptitle">Tip:</span> To secure sensitive information such as
                  usernames and passwords, you can use <a class="xref" href="../Pipeline_Configuration/RuntimeValues.html#concept_bs4_5nm_2s" title="Similar to runtime properties, runtime resources are values that you define in a file local to the Data Collector and call from within a pipeline. But with runtime resources, you can restrict the permissions for the files to secure sensitive information. Use runtime resources to load sensitive information from files at runtime.">runtime resources</a> or <span class="ph"><a class="xref" href="../Configuration/CredentialStores.html#concept_bt1_bpj_r1b" title="Data Collector pipeline stages communicate with external systems to read and write data. Many of these external systems require credentials - user names or passwords - to access the data. When you configure pipeline stages for these external systems, you define the credentials that the stage uses to connect to the system.">credential stores.</a></span></div>
</td>

                                </tr>

                            </tbody>

                        </table>
</div>

                </div>
            </li>
<li class="li step stepexpand">
                <span class="ph cmd">When using JDBC versions older than 4.0, on the <span class="ph uicontrol">Legacy
                        Drivers</span> tab, optionally configure the following
                    properties:</span>
                <div class="itemgroup info">
                    
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="task_kst_m4w_4y__d42825e3667" class="table" frame="border" border="1" rules="all">
                            
                            
                            <thead class="thead" align="left">
                                <tr>
                                    <th class="entry" valign="top" width="30%" id="d326216e2322">Legacy Driver Property</th>

                                    <th class="entry" valign="top" width="70%" id="d326216e2325">Description</th>

                                </tr>

                            </thead>

                            <tbody class="tbody">
                                <tr>
                                    <td class="entry" valign="top" width="30%" headers="d326216e2322 ">JDBC Class Driver Name</td>

                                    <td class="entry" valign="top" width="70%" headers="d326216e2325 ">Class name for the JDBC driver. Required for JDBC
                                        versions older than version 4.0.</td>

                                </tr>

                                <tr>
                                    <td class="entry" valign="top" width="30%" headers="d326216e2322 ">Connection Health Test Query</td>

                                    <td class="entry" valign="top" width="70%" headers="d326216e2325 ">Optional query to test the health of a connection.
                                        Recommended only when the JDBC version is older than 4.0.
                                    </td>

                                </tr>

                            </tbody>

                        </table>
</div>

                </div>
            </li>
<li class="li step stepexpand">
                <span class="ph cmd">On the <span class="keyword wintitle">Advanced</span> tab, optionally configure advanced
                    properties.</span>
                <div class="itemgroup info">The defaults for these properties should work in most cases:
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="task_kst_m4w_4y__table_z1c_hjj_kw" class="table" frame="border" border="1" rules="all">
                            
                            
                            <thead class="thead" align="left">
                                <tr>
                                    <th class="entry" valign="top" width="30%" id="d326216e2378">Advanced Property</th>

                                    <th class="entry" valign="top" width="70%" id="d326216e2381">Description</th>

                                </tr>

                            </thead>

                            <tbody class="tbody">
                                <tr>
       <td class="entry" valign="top" width="30%" headers="d326216e2378 ">Maximum Pool Size</td>

       <td class="entry" valign="top" width="70%" headers="d326216e2381 ">The maximum number of connections to create. Must be equal to or greater than the
        value of the Number of Threads property.<p class="p">Default is 1.</p>
</td>

      </tr>

                                <tr>
       <td class="entry" valign="top" width="30%" headers="d326216e2378 ">Minimum Idle Connections</td>

       <td class="entry" valign="top" width="70%" headers="d326216e2381 ">The minimum number of connections to create and maintain. To define a fixed connection
        pool, set to the same value as Maximum Pool Size. <p class="p">Default is 1. </p>
</td>

      </tr>

                                <tr>
       <td class="entry" valign="top" width="30%" headers="d326216e2378 ">Connection Timeout</td>

       <td class="entry" valign="top" width="70%" headers="d326216e2381 ">Maximum time to wait for a connection. Use a time constant in an expression to define
        the time increment. <div class="p">Default is 30 seconds, defined as follows:
         <pre class="pre codeblock">${30 * SECONDS}</pre>
</div>
</td>

      </tr>

                                <tr>
       <td class="entry" valign="top" width="30%" headers="d326216e2378 ">Idle Timeout</td>

       <td class="entry" valign="top" width="70%" headers="d326216e2381 ">Maximum time to allow a connection to idle. Use a time constant in an expression to
        define the time increment. <p class="p">Use 0 to avoid removing any idle connections.</p>
<div class="p">Default is
         30 minutes, defined as follows: <pre class="pre codeblock">${30 * MINUTES}</pre>
</div>
</td>

      </tr>

                                <tr>
       <td class="entry" valign="top" width="30%" headers="d326216e2378 ">Max Connection Lifetime</td>

       <td class="entry" valign="top" width="70%" headers="d326216e2381 ">Maximum lifetime for a connection. Use a time constant in an expression to define the
        time increment. <p class="p">Use 0 to avoid removing any idle connections.</p>
<div class="p">Default is 30
         seconds, defined as follows: <pre class="pre codeblock">${30 * SECONDS}</pre>
</div>
</td>

      </tr>

                                <tr>
       <td class="entry" valign="top" width="30%" headers="d326216e2378 ">Auto Commit</td>

       <td class="entry" valign="top" width="70%" headers="d326216e2381 ">Determines if auto-commit mode is enabled. In auto-commit mode, the database commits
        the data for each record. <p class="p">Default is disabled.</p>
</td>

      </tr>

                                <tr>
       <td class="entry" valign="top" width="30%" headers="d326216e2378 ">Enforce Read-only Connection</td>

       <td class="entry" valign="top" width="70%" headers="d326216e2381 ">Creates read-only connections to avoid any type of write. <p class="p">Default is enabled.
         Disabling this property is not recommended. </p>
</td>

      </tr>

                                <tr>
       <td class="entry" valign="top" width="30%" headers="d326216e2378 ">Transaction Isolation</td>

       <td class="entry" valign="top" width="70%" headers="d326216e2381 ">Transaction isolation level used to connect to the database. <p class="p">Default is the default
         transaction isolation level set for the database. You can override the database default by
         setting the level to any of the following:</p>
<ul class="ul" id="task_kst_m4w_4y__d42622e2672">
         <li class="li">Read committed </li>

         <li class="li">Read uncommitted </li>

         <li class="li">Repeatable read</li>

         <li class="li">Serializable</li>

        </ul>
</td>

      </tr>

                                <tr>
       <td class="entry" valign="top" width="30%" headers="d326216e2378 ">Initial Table Order Strategy <a class="xref" href="MultiTableJDBCConsumer.html#concept_nff_2hx_4y" title="You can define the initial order that the origin uses to read the tables."><img class="image" id="task_kst_m4w_4y__d42622e2693" src="../Reusable_Content/../Graphics/icon_moreInfo.png" height="12" width="12" />
        </a></td>

       <td class="entry" id="task_kst_m4w_4y__d42622e2696" valign="top" width="70%" headers="d326216e2381 ">Initial order used to read the tables:<ul class="ul" id="task_kst_m4w_4y__d42622e2698">
         <li class="li" id="task_kst_m4w_4y__d42622e2700">None - Reads the tables in the order that they are listed in
          the database.</li>

         <li class="li" id="task_kst_m4w_4y__d42622e2703">Alphabetical - Reads the tables in alphabetical order.</li>

         <li class="li">Referential Constraints - Reads the tables based on the dependencies between the
          tables.</li>

        </ul>
</td>

      </tr>

                                <tr>
       <td class="entry" valign="top" width="30%" headers="d326216e2378 ">Init Query</td>

       <td class="entry" valign="top" width="70%" headers="d326216e2381 ">SQL query to perform immediately after the stage connects to the database. Use to set
        up the database session as needed. <p class="p">For example, the following query sets the time zone
         for the session for a MySQL database: <samp class="ph codeph">SET time_zone =
        timezone;</samp></p>
</td>

      </tr>

                                <tr>
       <td class="entry" valign="top" width="30%" headers="d326216e2378 ">On Unknown Type</td>

       <td class="entry" valign="top" width="70%" headers="d326216e2381 ">Action to take when the origin encounters a record with an unsupported data type:<ul class="ul" id="task_kst_m4w_4y__d42622e2732">
         <li class="li">Stop Pipeline - Stops the pipeline after completing processing the previous
          records.</li>

         <li class="li">Convert to String - Converts the data to string and continues processing. </li>

        </ul>
</td>

      </tr>

                            </tbody>

                        </table>
</div>
</div>
            </li>
</ol>

    </div>

</div>
</div>
<div class="navfooter"><!---->
<span class="navparent"><a class="link" href="../Origins/Origins_title.html" title="Origins"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">Origins</span></a></span>  </div><div class="footer" id="webhelp_copyright_information"><!--

    Copyright 2017 StreamSets Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

--><!-- SDC google analytics --><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-60917135-3', 'auto');
  ga('send', 'pageview');
</script></div>
</body>
</html>